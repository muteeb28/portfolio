{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "encrypted-text",
  "type": "registry:component",
  "title": "Encrypted Text",
  "author": "Muteeb Masoodi",
  "description": "A Matrix-like text reveal effect where characters scramble before settling.",
  "dependencies": [
    "motion"
  ],
  "files": [
    {
      "path": "src/components/ui/encrypted-text.tsx",
      "content": "\"use client\";\r\nimport React, { useEffect, useRef, useState } from \"react\";\r\nimport { motion, useInView } from \"motion/react\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\ntype EncryptedTextProps = {\r\n    text: string;\r\n    className?: string;\r\n    /**\r\n     * Time in milliseconds between revealing each subsequent real character.\r\n     * Lower is faster. Defaults to 50ms per character.\r\n     */\r\n    revealDelayMs?: number;\r\n    /** Optional custom character set to use for the gibberish effect. */\r\n    charset?: string;\r\n    /**\r\n     * Time in milliseconds between gibberish flips for unrevealed characters.\r\n     * Lower is more jittery. Defaults to 50ms.\r\n     */\r\n    flipDelayMs?: number;\r\n    /** CSS class for styling the encrypted/scrambled characters */\r\n    encryptedClassName?: string;\r\n    /** CSS class for styling the revealed characters */\r\n    revealedClassName?: string;\r\n};\r\n\r\nconst DEFAULT_CHARSET =\r\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-={}[];:,.<>/?\";\r\n\r\nfunction generateRandomCharacter(charset: string): string {\r\n    const index = Math.floor(Math.random() * charset.length);\r\n    return charset.charAt(index);\r\n}\r\n\r\nfunction generateGibberishPreservingSpaces(\r\n    original: string,\r\n    charset: string,\r\n): string {\r\n    if (!original) return \"\";\r\n    let result = \"\";\r\n    for (let i = 0; i < original.length; i += 1) {\r\n        const ch = original[i];\r\n        result += ch === \" \" ? \" \" : generateRandomCharacter(charset);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport const EncryptedText: React.FC<EncryptedTextProps> = ({\r\n    text,\r\n    className,\r\n    revealDelayMs = 50,\r\n    charset = DEFAULT_CHARSET,\r\n    flipDelayMs = 50,\r\n    encryptedClassName,\r\n    revealedClassName,\r\n}) => {\r\n    const ref = useRef<HTMLSpanElement>(null);\r\n    const isInView = useInView(ref, { once: true });\r\n\r\n    const [revealCount, setRevealCount] = useState<number>(0);\r\n    const animationFrameRef = useRef<number | null>(null);\r\n    const startTimeRef = useRef<number>(0);\r\n    const lastFlipTimeRef = useRef<number>(0);\r\n    const scrambleCharsRef = useRef<string[]>(\r\n        text ? generateGibberishPreservingSpaces(text, charset).split(\"\") : [],\r\n    );\r\n\r\n    useEffect(() => {\r\n        if (!isInView) return;\r\n\r\n        // Reset state for a fresh animation whenever dependencies change\r\n        const initial = text\r\n            ? generateGibberishPreservingSpaces(text, charset)\r\n            : \"\";\r\n        scrambleCharsRef.current = initial.split(\"\");\r\n        startTimeRef.current = performance.now();\r\n        lastFlipTimeRef.current = startTimeRef.current;\r\n        setRevealCount(0);\r\n\r\n        let isCancelled = false;\r\n\r\n        const update = (now: number) => {\r\n            if (isCancelled) return;\r\n\r\n            const elapsedMs = now - startTimeRef.current;\r\n            const totalLength = text.length;\r\n            const currentRevealCount = Math.min(\r\n                totalLength,\r\n                Math.floor(elapsedMs / Math.max(1, revealDelayMs)),\r\n            );\r\n\r\n            setRevealCount(currentRevealCount);\r\n\r\n            if (currentRevealCount >= totalLength) {\r\n                return;\r\n            }\r\n\r\n            // Re-randomize unrevealed scramble characters on an interval\r\n            const timeSinceLastFlip = now - lastFlipTimeRef.current;\r\n            if (timeSinceLastFlip >= Math.max(0, flipDelayMs)) {\r\n                for (let index = 0; index < totalLength; index += 1) {\r\n                    if (index >= currentRevealCount) {\r\n                        if (text[index] !== \" \") {\r\n                            scrambleCharsRef.current[index] =\r\n                                generateRandomCharacter(charset);\r\n                        } else {\r\n                            scrambleCharsRef.current[index] = \" \";\r\n                        }\r\n                    }\r\n                }\r\n                lastFlipTimeRef.current = now;\r\n            }\r\n\r\n            animationFrameRef.current = requestAnimationFrame(update);\r\n        };\r\n\r\n        animationFrameRef.current = requestAnimationFrame(update);\r\n\r\n        return () => {\r\n            isCancelled = true;\r\n            if (animationFrameRef.current !== null) {\r\n                cancelAnimationFrame(animationFrameRef.current);\r\n            }\r\n        };\r\n    }, [isInView, text, revealDelayMs, charset, flipDelayMs]);\r\n\r\n    if (!text) return null;\r\n\r\n    return (\r\n        <motion.span\r\n            ref={ref}\r\n            className={cn(className)}\r\n            aria-label={text}\r\n            role=\"text\"\r\n        >\r\n            {text.split(\"\").map((char, index) => {\r\n                const isRevealed = index < revealCount;\r\n                const displayChar = isRevealed\r\n                    ? char\r\n                    : char === \" \"\r\n                        ? \" \"\r\n                        : (scrambleCharsRef.current[index] ??\r\n                            generateRandomCharacter(charset));\r\n\r\n                return (\r\n                    <span\r\n                        key={index}\r\n                        className={cn(isRevealed ? revealedClassName : encryptedClassName)}\r\n                    >\r\n                        {displayChar}\r\n                    </span>\r\n                );\r\n            })}\r\n        </motion.span>\r\n    );\r\n};\r\n",
      "type": "registry:component"
    }
  ]
}